# Examples of Framework Usage

Begriff uses a simple framework to organize the code. Here are some examples that explain what it is about.

The examples are generated by an LLM and then reviewed and edited by @krvkir, so they are correct about the architecture and guiding principles behind it.

Examples start simple and then go to extended features of the framework, so it is reasonable to read the doc from the beginning.

#### How to handle a simple command and start a process?
This example shows how to register a simple `/start` command. When triggered, it sends a welcome message and then emits a signal on the event bus to begin the onboarding process. This decouples the command invocation from the process itself.

```python
# From: app/onboarding.py

# A signal to indicate the onboarding process should begin.
@dataclass
class OnboardingStarted(Signal):
    user_id: int

# The @router.command decorator registers the function as a handler for the /start command.
# The @router.authorize decorator checks user permissions and injects a `user: User` object.
@router.command("start", description="Start using the bot")
@router.authorize()
async def start(ctx: Context, user: User) -> None:
    """Launch the onboarding process."""
    # `ctx.send_message` sends a message to the user. It can handle
    # TranslatableStrings, automatically resolving them based on the user's locale.
    await ctx.send_message(
        _(
            """
Welcome to the Begriff Bot! I'll help you learn new words in a foreign language.

In a few steps we'll set up things and start.      
""",
        )
    )
    # `bus.emit` places a signal onto the event bus. Other parts of the system
    # can listen for this signal and react accordingly. This promotes loose coupling.
    # We pass `ctx` so the handler can use it.
    bus.emit(OnboardingStarted(user.id), ctx=ctx)

```
The `router` object serves as the primary entry point for user interactions like commands, messages, or reactions. Handlers are simple asynchronous functions that receive a `Context` object and any parameters from the decorator.

The `bus` object implements a signal/slot pattern. You `emit` signals to represent events, and handlers decorated with `@bus.on(...)` will be executed. This is ideal for chaining actions and decoupling components.

The `@router.authorize()` decorator handles user authentication. It retrieves the user from the database and injects it as a `user: User` argument into the decorated function, simplifying handlers.

#### How to handle user messages matching a pattern?
You can process any user message that doesn't start with a `/`. The `@router.message` decorator accepts a regular expression. If the pattern contains named groups, the matched values are passed as keyword arguments to the handler.

```python
# From: app/recap.py

# The pattern uses a named group `(?P<url>...)` to capture the URL.
# This `url` will be passed as a keyword argument to the `recap_url` function.
@router.message(re.compile(r"(?P<url>https?://\S+)$", re.MULTILINE))
@router.authorize()
async def recap_url(ctx: Context, user: User, url: str) -> None:
    """
    Handles messages containing a URL.

    Args:
        ctx: The context object for the current interaction.
        user: The authorized user, injected by the decorator.
        url: The URL string captured by the regex's named group.
    """
    language = get_language(
        user.get_option(
            "studied_language", Config.LANGUAGE["defaults"]["study"]
        )
    )

    # ... logic to get a recap of the URL ...
    recap = await get_recap(url, language.name, notes=None)
    response = f"{recap} [(source)]({url})"

    # The `reply_to` argument makes the bot's message a direct reply
    # to the user's original message.
    await ctx.send_message(
        text=response,
        reply_to=ctx.message,
    )

```
The framework passes captured named groups from the regex pattern directly to the handler function as keyword arguments. This makes extracting data from user messages straightforward. The `ctx.message` attribute provides access to the message that triggered the handler.

#### How to use inline keyboards and handle button presses?
This is a two-part process. First, you send a message with an inline keyboard. Each button in the keyboard is associated with a `Signal` instance. When a user presses a button, the framework emits that signal, which is then caught by a handler decorated with `@bus.on(...)`.

```python
# From: app/study.py

# This signal is attached to the "ANSWER" button. It carries the card's ID.
@dataclass
class CardAnswerRequested(Signal):
    card_id: int

# This function sends the initial message with the keyboard.
@bus.on(CardGraded)  # This handler can be triggered by another event.
@router.authorize()
async def study_next_card(ctx: Context, user: User) -> None:
    # ... logic to find the next card to study ...
    card = get_cards(user_id=user.id, ...)[0]

    # The Keyboard object is a list of lists of Buttons.
    # The Button's `callback` argument is a Signal instance.
    keyboard = Keyboard([[Button(_("ANSWER"), CardAnswerRequested(card.id))]])

    # The message is sent with the keyboard attached.
    return await ctx.send_message(card.front, keyboard)


# This function handles the button press.
# The `@bus.on` decorator links this handler to the `CardAnswerRequested` signal.
@bus.on(CardAnswerRequested)
@router.authorize()
async def handle_study_answer(ctx: Context, user: User, card_id: int) -> None:
    """
    Handles the "ANSWER" button press.

    Args:
        ctx: The context object.
        user: The authorized user.
        card_id: The value from the `CardAnswerRequested` signal's `card_id` field.
    """
    # ... logic to show the card's answer and a new keyboard for grading ...
    # The framework automatically unpacks the signal's fields (`card_id`)
    # and passes them as keyword arguments to the handler.
    card = get_card(card_id)
    # ...
    await ctx.send_message(f"{card.front}\n\n{card.back}", new_keyboard)
```
The core mechanic is the `Button` object, which pairs display text with a `Signal` payload. The `telegram` adapter serializes this signal into the `callback_data` field. When a button is pressed, the adapter deserializes it and emits the signal on the `bus`. The signal's dataclass fields are passed as arguments to the corresponding handler, creating a type-safe and decoupled way to handle callbacks.

#### How to build a dynamic keyboard for navigation?
For more complex interactions like a paginated list, you can dynamically generate the `Keyboard` object based on the current state. The state (e.g., current page number) is passed via the `Signal` attached to the navigation buttons.

```python
# From: app/note_list.py

# Signal for navigating the notes list. It carries all necessary state.
@dataclass
class NotesListRequested(Signal):
    user_id: int
    language_id: int
    maturity_filter: Maturity
    page: int = 1

# This function displays the list and the navigation controls.
async def display_notes_by_maturity(
    ctx: Context, user: User, language: Language, maturity_to_display: Maturity, page: int = 1
) -> None:
    all_notes = get_notes(...)
    total_pages = ...
    notes_on_page = ...

    all_keyboard_rows = []
    # Create a button for each note on the current page.
    for note_item in notes_on_page:
        all_keyboard_rows.append([Button(note_item.field1, NoteSelected(user.id, note_item.id))])

    # Create pagination buttons. Each button creates a new signal with the target page number.
    if total_pages > 1:
        pagination_row = []
        if page > 1:
            pagination_row.append(
                Button("â¬…ï¸ Prev", NotesListRequested(user.id, language.id, maturity_to_display, page - 1))
            )
        # ... more buttons for page numbers, next page etc. ...
        all_keyboard_rows.append(pagination_row)

    await ctx.send_message("List of notes...", markup=Keyboard(all_keyboard_rows))

# This handler is triggered by any of the navigation buttons.
@bus.on(NotesListRequested)
@router.authorize()
async def handle_list_notes_by_maturity_request(
    ctx: Context, user: User, language_id: int, maturity_filter: Maturity, page: int
) -> None:
    # The arguments are unpacked from the signal.
    language = get_language(language_id)
    # Re-render the list display with the new state.
    # By default, ctx.send_message will edit the existing message if called
    # from a callback query, providing a smooth navigation experience.
    await display_notes_by_maturity(ctx, user, language, maturity_filter, page)
```
This pattern creates a self-contained component. The state is not stored on the server but is encoded in the buttons themselves. When a button is pressed, the handler receives the new state, fetches the data, and re-renders the component by editing the original message.

#### How to handle message reactions?
The framework can also handle reactions (e.g., ðŸ‘, ðŸ‘Ž) to messages. The `@router.reaction` decorator registers a handler for a list of emojis. A key feature is the ability to set `conditions` that must be met in the context of the message being reacted to.

```python
# From: app/note.py

# This handler triggers when a user reacts with "ðŸ‘Ž" to a message
# that has a `note_id` in its context.
@router.reaction(["ðŸ‘Ž"], conditions={"note_id": Any})
@router.authorize()
async def handle_negative_reaction(
    ctx: Context, user: User, reply_to: Message, note_id: int
):
    """
    Handles a negative reaction to regenerate a note's explanation.

    Args:
        ctx: The context object.
        user: The authorized user.
        reply_to: The `Message` object that was reacted to, injected by the framework.
        note_id: The value for the `note_id` key from the reacted message's context,
                 injected because it was specified in `conditions`.
    """
    if not (note := get_note(note_id)):
        return

    # ... logic to regenerate the explanation for the note ...
    new_explanation = await get_explanation(note.field1, ...)
    note.field2 = new_explanation
    update_note(note)

    # Send a new message with the updated explanation.
    new_message = await ctx.send_message(f"ðŸ”„ *{note.field1}* â€” {new_explanation}")

    # Associate the new message with the same note_id, so it can also be reacted to.
    ctx.context(new_message)["note_id"] = note.id
```
When a message is sent, you can attach arbitrary data to it using `ctx.context(message)[key] = value`. When a user reacts to that message, the `@router.reaction` decorator checks if the message's context satisfies the `conditions`. If it does, the handler is called, and the values from the context matching the keys in `conditions` are passed as keyword arguments. The reacted-to message itself is passed as the `reply_to` argument.

#### How to manage a multi-step conversation?
For simple, sequential conversations, you can manage state using the context persistence layer. One handler can set a state flag in the user's context data, and a subsequent generic message handler can check for this flag to determine how to process the input.

```python
# From: app/note_list.py

# This handler is triggered by a button press to start the editing process.
@bus.on(NoteTitleEditRequested)
@router.authorize()
async def handle_note_title_edit_requested(
    ctx: Context, user: User, note_id: int
):
    # Set a flag in the user's persistent context to indicate an edit is active.
    # `ctx.context(user)` provides a dictionary for storing user-specific data.
    ctx.context(user)["active_edit"] = {
        "note_id": note_id,
        "field_to_edit": "field1",
    }
    await ctx.send_message("Please send the new title for the note.")


# This is a generic message handler that will catch the user's next text message.
@router.message(lambda text: not text.startswith('/')) # A filter to catch any non-command text.
@router.authorize()
async def handle_note_edit_input(ctx: Context, user: User):
    # Check if we are in an active edit session.
    active_edit_info = ctx.context(user).get("active_edit")
    if not active_edit_info:
        # Not an edit. Let other handlers process this, or do nothing.
        return True # Indicate that this handler did not consume the message.

    note_id = active_edit_info["note_id"]
    new_value = ctx.message.text.strip()

    # ... logic to find the note and update it with `new_value` ...
    note_to_edit = get_note(note_id)
    note_to_edit.field1 = new_value
    db.session.commit()

    await ctx.send_message(f"Note title updated to: '{new_value}'")

    # Clean up the state flag to end the conversation.
    del ctx.context(user)["active_edit"]
```
This pattern uses `ctx.context(user)` as a simple key-value store for session state. The first function initiates the "conversation" by setting a key (`active_edit`). The next message handler checks for this key. If present, it processes the message as part of the conversation and then clears the key to end the flow. This avoids complex state machines for simple request-response interactions.


#### How to manage a multi-step conversation? The Better Way

##### Before: Using Manual State Flags

The previous implementation relied on setting a flag (`active_edit`) in the user's persistent context. A generic message handler then had to check for this flag on every incoming message.

```python
# From: app/note_list.py (Old Implementation)

@bus.on(NoteTitleEditRequested)
@router.authorize()
async def handle_note_title_edit_requested(
    ctx: Context, user: User, note_id: int
):
    # Sets a flag in the user's context data.
    ctx.context(user)["active_edit"] = {
        "note_id": note_id,
        "field_to_edit": "field1",
    }
    await ctx.send_message("Please send the new title for the note.")


# A generic message handler that must check for the flag.
@router.message(".*")
@router.authorize()
async def handle_note_edit_input(ctx: Context, user: User):
    if "active_edit" not in ctx.context(user):
        return True # Not an edit, pass to other handlers.

    active_edit_info = ctx.context(user)["active_edit"]
    # ... logic to update note ...
    # Must remember to clean up the flag.
    del ctx.context(user)["active_edit"]
```
This approach is functional but brittle. It requires careful state management and can lead to conflicts if multiple features use generic message handlers.

##### After: Using `on_reply`

The `on_reply` mechanism eliminates manual state management. We define a new signal that will be triggered by the user's next message.

First, we define new signals to represent the submission of the new content.

```python
# From: app/note_list.py (New Signals)

@dataclass
class NoteTitleSubmitted(Signal):
    user_id: int
    note_id: int


@dataclass
class NoteExplanationSubmitted(Signal):
    user_id: int
    note_id: int

```

Next, we modify the handler that requests the edit. Instead of setting a state flag, it uses `on_reply` to register the `NoteTitleSubmitted` signal to be emitted with the user's next message.

```python
# From: app/note_list.py (New "Request Edit" Handler)

@bus.on(NoteTitleEditRequested)
@router.authorize()
async def handle_note_title_edit_requested(
    ctx: Context, user: User, note_id: int
):
    logger.info(
        f"User {user.login} requested to edit title for note {note_id}"
    )
    # ... (code to get note and check ownership) ...

    # The key change: pass the `on_reply` argument.
    # The framework will now wait for the user's next message
    # and emit `NoteTitleSubmitted` when it arrives.
    await ctx.send_message(
        "Please send the new title for the note.",
        on_reply=NoteTitleSubmitted(user.id, note_id)
    )
```

Finally, we replace the generic message handler with a specific signal handler that listens for `NoteTitleSubmitted`. This new handler is cleaner, more focused, and does not need to manage any state flags.

```python
# From: app/note_list.py (New "Handle Submission" Handler)

# This handler directly catches the user's reply.
@bus.on(NoteTitleSubmitted)
@router.authorize()
async def handle_note_title_submitted(
    ctx: Context, user: User, note_id: int
):
    note_to_edit = get_note(note_id)
    # ... logic to update note ...
    db.session.commit()
    await ctx.send_message(f"Note title updated to: '{new_value}'")
```
This approach is preferable for several reasons:

-   *No State Management*: It eliminates the need to manually set and clear flags like `active_edit` from the user's context.
-   *Decoupling*: The logic is contained in specific signal handlers (`...Requested`, `...Submitted`) rather than a single, complex message handler that must inspect conversational state.
-   *Robustness*: It avoids conflicts between different features that might otherwise compete to handle a generic text message. The framework directs the user's reply to the correct handler automatically.

#### How to handle internationalization (i18n)?
The framework is designed for easy internationalization. You write all user-facing strings in English using the `TranslatableString` class (commonly aliased to `_`), and the framework handles translation at runtime.

```python
# From: app/onboarding.py

# It is a common convention to alias TranslatableString to a short name like _.
from core.i18n import TranslatableString as _
from babel import Locale

# ...

# A TranslatableString can be used anywhere a string is expected,
# including in command descriptions.
@router.command("start", description=_("Start using the bot"))
@router.authorize()
async def start(ctx: Context, user: User) -> None:
    # This creates a translatable object. The framework automatically collects
    # all such strings, which can then be extracted into standard .po files
    # for translators.
    await ctx.send_message(
        _(
            """
Welcome to the Begriff Bot! I'll help you learn new words in a foreign language.

In a few steps we'll set up things and start.
""",
        )
    )
    bus.emit(OnboardingStarted(user.id), ctx=ctx)


@bus.on(StudyLanguageSelected)
@router.authorize()
async def save_studied_language(ctx: Context, user: User, language_code: str):
    locale = Locale.parse(language_code)
    language = get_language(locale.get_language_name("en"))

    # TranslatableString also supports f-string-like placeholders.
    # The values are passed during the creation of the object.
    # The `resolve` function will format the translated string with these values.
    await ctx.send_message(
        _(
            "You selected: {flag}{language}",
            flag=get_flag(ctx, locale),
            language=locale.get_language_name(ctx.user.locale.language),
        )
    )
    bus.emit(StudyLanguageSaved(user.id, language.id), ctx=ctx)
```
The internationalization system works as follows:
1.  You define all user-facing strings as `TranslatableString("Your English string here")`.
2.  When `ctx.send_message` receives such an object, it automatically calls an internal `resolve` function, passing the string and the user's locale (`ctx.user.locale`).
3.  The `resolve` function looks for a translation in the appropriate `.po` file for the user's language.
4.  If a translation is found, it's returned. If not, the system can be configured to use a service (like an LLM) to generate a translation on-the-fly and save it for future use.
5.  If no translation can be found or generated, it safely falls back to the original English string.
This approach keeps the code clean and readable in one language while automating the translation process.

#### How to add contextual help messages to handlers?
You can attach a help message to the specific message sent by a handler. This help can be triggered by the user reacting to that message (e.g., with `ðŸ¤”`) or replying to it with `/help`. This is achieved with the `@router.help` decorator.

```python
# From: app/study.py

from core.i18n import TranslatableString as _

# ...

# The `@router.help` decorator attaches a contextual help message.
# The help text itself is a TranslatableString, so it will be internationalized.
@router.help(
    _(
        "Here you see the question. Try to remember the answer. If you come up with it, press ANSWER to check yourself. If you can't remember it for 10 seconds, don't try too hard, press ANSWER and try to memorize the answer."
    )
)
@bus.on(CardGraded)
@router.authorize()
async def study_next_card(ctx: Context, user: User) -> None:
    # ... logic to fetch a card ...
    card = get_cards(...)[0]
    note = card.note
    keyboard = Keyboard([[Button(_("ANSWER"), CardAnswerRequested(card.id))]])

    # To enable the help system, the handler MUST return the `Message` object
    # that was sent to the user.
    message = await ctx.send_message(
        card.front,
        keyboard,
        # This context is for other features, like the reaction handler for bad explanations.
        context={"note_id": note.id, "card_id": card.id},
    )
    return message # Returning the message object is critical.
```
The mechanism behind `@router.help` is powerful yet simple to use:
1.  The decorator takes a help string. It generates a unique, internal hash from this string.
2.  It automatically registers two "hidden" handlers:
    - A command handler: `@router.command("help", conditions={"_help": hash})`
    - A reaction handler: `@router.reaction(["ðŸ¤”", "ðŸ¤¯"], conditions={"_help": hash})`
    - Both of these handlers are programmed to simply send the provided help text.
3.  The decorator then wraps your `study_next_card` function. After your function runs and returns a `Message` object, the wrapper injects the unique hash into that specific message's context: `ctx.context(message)["_help"] = hash`.
4.  Now, if a user replies `/help` to that particular message or reacts with `ðŸ¤”` or `ðŸ¤¯`, the `conditions` of the hidden handlers are met, and the contextual help is displayed. This keeps the help system tightly coupled to the specific UI element it's explaining.

### 

<!-- Local Variables: -->
<!-- gptel-model: gemini-2.5-pro-preview-05-06 -->
<!-- gptel--backend-name: "Gemini" -->
<!-- gptel--bounds: ((response (1 8) (9 23) (24 51) (52 62) (63 77) (78 105) (106 110) (111 117) (118 123) (124 142) (143 150) (151 183) (184 211) (212 214) (215 223) (224 246) (247 252) (253 281) (282 287) (288 302) (303 316) (317 324) (325 356) (357 367) (368 387) (388 399) (400 412) (413 13156) (13159 13206) (13207 17001) (17003 22086))) -->
<!-- End: -->
