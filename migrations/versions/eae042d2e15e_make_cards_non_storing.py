"""Make cards non-storingoring

Revision ID: eae042d2e15e
Revises: ac5e7d079c94
Create Date: 2025-07-27 15:50:26.658463

"""

from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import table, column


# revision identifiers, used by Alembic.
revision = "eae042d2e15e"
down_revision = "ac5e7d079c94"
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    cards_table = table(
        "cards",
        column("id", sa.Integer),
        column("note_id", sa.Integer),
        column("front", sa.String),
        column("back", sa.String),
        column("type", sa.String),
    )
    notes_table = table(
        "notes",
        column("id", sa.Integer),
        column("field1", sa.String),
        column("field2", sa.String),
    )

    # Set card type based on front/back fields
    op.execute(
        cards_table.update()
        .values(type="direct_card")
        .where(cards_table.c.note_id == notes_table.c.id)
        .where(cards_table.c.front == notes_table.c.field1)
        .where(cards_table.c.back == notes_table.c.field2)
    )
    op.execute(
        cards_table.update()
        .values(type="reverse_card")
        .where(cards_table.c.note_id == notes_table.c.id)
        .where(cards_table.c.front == notes_table.c.field2)
        .where(cards_table.c.back == notes_table.c.field1)
    )

    with op.batch_alter_table("cards", schema=None) as batch_op:
        batch_op.drop_column("back")
        batch_op.drop_column("front")

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table("cards", schema=None) as batch_op:
        batch_op.add_column(sa.Column("front", sa.VARCHAR(), nullable=True))
        batch_op.add_column(sa.Column("back", sa.VARCHAR(), nullable=True))

    cards_table = table(
        "cards",
        column("id", sa.Integer),
        column("note_id", sa.Integer),
        column("front", sa.String),
        column("back", sa.String),
        column("type", sa.String),
    )
    notes_table = table(
        "notes",
        column("id", sa.Integer),
        column("field1", sa.String),
        column("field2", sa.String),
    )

    # Populate front/back fields based on card type
    op.execute(
        cards_table.update()
        .values(front=notes_table.c.field1, back=notes_table.c.field2)
        .where(cards_table.c.note_id == notes_table.c.id)
        .where(cards_table.c.type == "direct_card")
    )
    op.execute(
        cards_table.update()
        .values(front=notes_table.c.field2, back=notes_table.c.field1)
        .where(cards_table.c.note_id == notes_table.c.id)
        .where(cards_table.c.type == "reverse_card")
    )

    with op.batch_alter_table("cards", schema=None) as batch_op:
        batch_op.alter_column("front", nullable=False)
        batch_op.alter_column("back", nullable=False)

    # ### end Alembic commands ###
